  INCLUDE <P18F452.INC>

; ////////////////////////////////////////////////////////////////////////////////////////////
; ////////////////////////////////////////   MACROS   ////////////////////////////////////////
; ////////////////////////////////////////////////////////////////////////////////////////////

; ****************************************** MOVLF *******************************************
MOVLF MACRO LITERAL, FILEREG ; MOVE "LITERAL" VALUE TO "FILEREG" REGISTER
 MOVLW LITERAL
 MOVWF FILEREG 
 ENDM



; ////////////////////////////////////////////////////////////////////////////////////////////
; ///////////////////////////////////////   DEFINES   ////////////////////////////////////////
; ////////////////////////////////////////////////////////////////////////////////////////////

; *********************************** CONSTANT "LITERALS" ************************************
PR2VAL     EQU D'255'      ; PWM_frequency = 60Hz (MAX OUT PR2)
CCPCON     EQU B'00101100'
PRECISION  EQU B'11111000' ; VALUE USED TO TRUNCATE TO A PRECISION OF 8

; ************************************* NAMED REGISTERS **************************************
 CBLOCK 0x0E
W_TEMP
WAITCOUNTER ; HOLDS THE VALUE TO WAIT THE REQUIRED AQUISITION TIME FOR A/D CONVERSIONS
AN0REG      ; HOLDS THE RESULT OF THE A/D CONVERSION LINKED TO PIN AN0
AN1REG      ; HOLDS THE RESULT OF THE A/D CONVERSION LINKED TO PIN AN1
AN2REG      ; HOLDS THE RESULT OF THE A/D CONVERSION LINKED TO PIN AN2
AN3REG      ; HOLDS THE RESULT OF THE A/D CONVERSION LINKED TO PIN AN3
ANWREG      ; WORKING REGISTER FOR THE ANxREG VALUES SO THEY ARE NOT MODIFIED DRUING CALCULATIONS
 ENDC

 CBLOCK 0x20
FWDMAX     ; HOLDS THE REGISTER VALUE THAT CORRISPONDS TO THE MAX FORWARD SPEED WE WANT TO DRIVE AT
FWDMIN     ; HOLDS THE REGISTER VALUE THAT CORRISPONDS TO THE MIN FORWARD SPEED WE CAN DRIVE AT
REVMAX     ; HOLDS THE REGISTER VALUE THAT CORRISPONDS TO THE MAX REVERSE SPEED WE WANT TO DRIVE AT
REVMIN     ; HOLDS THE REGISTER VALUE THAT CORRISPONDS TO THE MIN REVERSE SPEED WE CAN DRIVE AT
REVVAL     ; HOLDS THE VALUE THAT WILL BE THE THRESHOLD FOR SWITCHING BETWEEN FORWARD AND REVERSE (AN2REG > REVVAL = REVERSE)
LTURNMAX   ; HOLDS THE MAXIMUM REGISTER VALUE WE WILL USE TO TURN LEFT
LTURNMIN   ; HOLDS THE MINIMUM REGISTER VALUE WE WILL USE TO TURN LEFT
NTURNVAL   ; HOLDS THE REGISTER VALUE TO TELL THE CAR TO GO STRAIGHT
RTURNMAX   ; HOLDS THE MAXIMUM REGISTER VALUE WE WILL USE TO TURN RIGHT
RTURNMIN   ; HOLDS THE MINIMUM REGISTER VALUE WE WILL USE TO TURN RIGHT
 ENDC

; ********************************** CUSTOM FLAG REGISTERS ***********************************
 CBLOCK 0x30 ; SEE EQUs BELOW FOR MORE INFO ON WHAT EACH BIT REPRESENTS
CCR   ; CAR CONTROL REGISTER
 ENDC

CALCSTEER EQU D'0' ; CCR BIT TO FLAG LOOPDALOOP TO RECALC DIRECTION
CALCDRIVE EQU D'1' ; CCR BIT TO FLAG LOOPDALOOP TO RECALC SPEED
TURNLEFT  EQU D'2' ; CCR BIT TO FLAG TURNING LEFT OR RIGHT

TURNINGLEFT  EQU D'7' ; ANWREG BITS TO FLAG WHAT DIRECTION WE ARE CURRENTLY TURNING IN
TURNINGRIGHT EQU D'6' ; 00xx xxxx = GOING STRAIGHT
                      ; 01xx xxxx = TURNING RIGHT
                      ; 10xx xxxx = TURNING LEFT

 CBLOCK 0x37
PRECISION0
PRECISION1
PRECISION2
PRECISION3
PRECISION4
 ENDC

; ////////////////////////////////////////////////////////////////////////////////////////////
; ////////////////////////////////////////   CODE   //////////////////////////////////////////
; ////////////////////////////////////////////////////////////////////////////////////////////

 ORG 0x00
 BRA START

 ORG 0x08
 BRA INTERRUPTHANDLER
 RETFIE
 
 ORG 0x18
 RETFIE



; ////////////////////////////////////////////////////////////////////////////////////////////
; /////////////////////////////////////// THE PROGRAM ////////////////////////////////////////
; ////////////////////////////////////////////////////////////////////////////////////////////

; ************************************ START THE PROGRAM *************************************
 ORG 0x40
START:
 LFSR FSR0, AN0REG     ; SET FSR0 TO AN0REG TO MANAGE RESULT REGISTERS
 LFSR FSR1, PRECISION0 ; 
 CALL INITREGISTERLIMS ; INITIALIZE THE BOUNDS OF THE REGISTER VALUES TO CONTROL THE CAR
 CALL INITPRECISION    ; INITIALIZE THE PRECISION VALUES FOR PRECISION BASED ON SPEED
 CALL INITIO           ; SET UP I/O PINS FOR A/D CONVERSION AND DISPLAYING RESULT ON LEDS
 CALL INITPWM          ; SET UP PULSE-WIDTH MODULATION FOR CONTROLLING THE CAR
 CALL INITADINTERRUPTS ; ENABLE ALL FLAGS NECESSARY FOR A/D CONVERSION INTERRUPTS
 CALL INITADC          ; SET UP THE A/D CONVERSION PROCESS
 BRA  LOOPDALOOP       ; INFINITE LOOP OF CONVERSION

; ************************************* LOOP INFINITELY **************************************
LOOPDALOOP:
 CLRWDT
 BTFSC CCR, CALCDRIVE ; CHECK IF THE FRONT SHORT RANGE SENSOR HAS UPDATED ITS VALUE
 CALL  DRIVE          ; IF WE AREN'T CURRENTLY BEING INTERRUPTED WITH SAVING A READ FROM A SENSOR
 BTFSC CCR, CALCSTEER ; CHECK IF THE LONG RANGE SENSORS HAVE BOTH UPDATED THEIR VALUE
 CALL  STEER          ; WE WILL CONTINUALLY READ FROM THE STORAGE REGISTERS AND CALCUALTE CONTORL
 BRA   LOOPDALOOP     ; LOGIC FOR THE CAR.



; ////////////////////////////////////////////////////////////////////////////////////////////
; ///////////////////////////////////// CONTROL ROUTINES /////////////////////////////////////
; ////////////////////////////////////////////////////////////////////////////////////////////

; ****************************************** DRIVE *******************************************
DRIVE:
 BCF    CCR, CALCDRIVE
 MOVF   AN2REG, W    ; MOVE THE VALUE READ FROM THE FRONT SHORT RANGE SENSOR TO WREG
 ;BTFSC WREG, 6      ; CHECK IF THE VALUE WE READ IS GREATER THAN 128 (THE 3-BIT IS WHAT THE 7-BIT WAS)
 CPFSGT REVVAL       ; IF REVVAL >  WREG,   THEN SKIP GOING IN REVERSE
 BRA    DRIVEREVERSE ; IF WREG   >= REVVAL, THEN DTRIVE IN REVERSE
 RLCF   WREG         ; ROTATE WREG LEFT BY 1 BIT TO GET 4-MSBs OF THE VALUES FOR DRIVING FORWARD
 ANDLW  B'11110000'  ; TRUNCATE THE VALUE TO ONLY KEEP THE 4 MSBs (THAT IS ALL WE ARE CONCERNED WITH)
 SWAPF  WREG         ; SWAP NIBBLES OF THE VALUE WE READ TO SET IT TO A VALUE RANGE OF 0-15
 NEGF   WREG         ; GET THE NEGATIVE VALUE OF THE MSBs WE HAVE LEFT
 ADDWF  FWDMAX, W    ; ADD THE CAP TO THE NEGATIVE OF THE VALUE WE READ SO WE EFFCTIVELY DO (CAP - VAL)
                     ; WE DO THIS BECAUSE THE FARTHER AWAY THE SURFACE WE READ FROM, THE LOWER THE VALUE IN THE
                     ; REGISTER WHICH MEANS THE LOWER VALUE WE READ, THE FASTER WE WANT TO GO.
 CPFSLT FWDMIN      ; IF THE MINIMUM FOWARD VALUE IS LESS THAN WHAT WE HAVE CALCULATED, DO NOTHING WITH IT
 MOVF   FWDMIN, W   ; OTHERWISE, IF THE VALUE WE CALCULATED IS LOWER, DRIVE AT THE MIN SPEED SO MOVE MIN -> WREG
 MOVWF  CCPR1L      ; SET SPEED AS VALUE IN WREG
 RETURN

DRIVEREVERSE:
 BSF   CCR,    TURNLEFT     ; IF WE ARE DRIVING IN REVERSE, INVERT THE NORMAL STEERING LOGIC SO WE TURN IN THE CORRECT DIRECTION
 BTFSC ANWREG, TURNINGRIGHT ; CHECK IF WE ARE CURRENTLY TURNING RIGHT
 BRA   SETTURNLEFT          ; IF WE ARE, SWITCH TO TURNING LEFT
 BTFSC ANWREG, TURNINGLEFT  ; IF WE AREN'T TURNING RIGHT, CHECK IF WE ARE CURRENTLY TURNING LEFT
 BRA   SETTURNRIGHT         ; IF WE ARE, SWITCH TO TURNING RIGHT

RETFROMSWITCH: ; BOTH DIRECTION CHANGE BRANCHES WILL JUMP BACK TO THIS POINT
 LFSR   FSR1,   PRECISION0 ; SET THE PRECISION POINTER TO MAX PRECISION FOR OPTIMAL STEERING WHILE GOING IN REVERSE
 MOVFF  REVMAX, CCPR1L     ; SET THE SPEED TO THE REVERSE VALUE

; NEGF   WREG          ; GET THE NEGATIVE VALUE OF THE MSBs WE HAVE LEFT
; ADDWF  REVMIN, W     ; ADD THE MIN SPEED VAL (MAX REGISTER VALUE) FOR DRIVING IN REVERSE
; CPFSLT REVMAX        ; IF THE MAXIMUM REVERSE VALUE (MIN REGISTER VALUE) IS LESS THAN WHAT WE HAVE CALCULATED, DO NOTHING WITH IT
; MOVF   REVMAX, W     ; OTHERWISE, IF THE VALUE WE CALCULATED IS LOWER, REVERSE AT THE MAX SPEED SO MOVE MAX -> WREG
; MOVWF  CCPR1L        ; SET SPEED AS VALUE IN WREG
 RETURN

SETTURNRIGHT:
 BCF   ANWREG, TURNINGLEFT
 MOVF  ANWREG, W
 ADDWF RTURNMIN, W   ; ADD MINIMUM RIGHT TURN VALUE (RTRUNMIN + TURN VALUE)
 MOVWF CCPR2L        ; LOAD THE CALCULATED STEER VALUE
 BRA   RETFROMSWITCH

SETTURNLEFT:
 BCF   ANWREG, TURNINGRIGHT
 MOVF  ANWREG, W
 NEGF  WREG          ; GET NEGATEIVE VALUE OF 4-MSBs
 ADDWF LTURNMIN, W   ; ADD MINIMUM LEFT TURN VALUE (LTRUNMIN - TURN VALUE)
 MOVWF CCPR2L        ; LOAD THE CALCULATED STEER VALUE
 BRA   RETFROMSWITCH

; ****************************************** STEER *******************************************
STEER:
 BCF    CCR, CALCSTEER   ; CLEAR THE STEER FLAG UNTIL THE NEXT SET OF VALUES ARE READ
 BTFSS  CCR, TURNLEFT    ; IF THE STEERLEFT BIT IS ALREADY SET, IT MUST HAVE BEEN SET BY THE DRIVEREVERSE LOGIC
 CALL   CALCPRECISION    ; SO IF IT'S CLEAR, GET THE PRECISION FOR THE SPEED WE ARE GOING, OTHERWISE USE MAX PRECISION
                         ; WHICH THE DRIVEREVERSE BLOCK ALREADY LOADED FOR US
 MOVF   INDF1, W         ; SET THE PRECISION THAT WAS DECIDED BASED ON SPEED OR DIRECTION
 ANDWF  AN1REG, W        ; TRUNCATE THE VALUE READ FROM AN1 (RIGHT-HAND LONG RANGE SENSOR) AND STORE IN WREG
 MOVWF  ANWREG           ; MOVE THE TRUNCATED VALUE OF AN1REG TO THE ANxREG WORKING REGISTER
 MOVF   INDF1, W         ; RESET THE PRECISION THAT WAS DECIDED BASED ON SPEED AS WREG NO LONGER HOLDS IT
 ANDWF  AN0REG, W        ; TRUNCATE THE VALUE READ FROM AN0 (LEFT-HAND LONG RANGE SENSOR) AND STORE IN WREG
 CPFSEQ ANWREG           ; COMPARE AN0 AND AN1 VALUES. IF THEY ARE THE SAME; DON'T STEER, JUST GO STRAIGHT
 BRA    TURN             ; IF THE VALUES READ OFF AN0 AND AN1 ARE NOT EQUAL, DECIDE HOW TO TURN
 MOVFF  NTURNVAL, CCPR2L ; THE VALUES WERE EQUAL SO GO STRAIGHT
 BCF    CCR, TURNLEFT    ; CLEAR THE TURN FLAG AT THE END OF THE STEER LOGIC SO THAT IF WE ARE IN REVERSE 
                         ; (DRIVING IS CALCULATED JUST BEFORE STEERING) WE CAN FLIP OUR TURNING BY TELLING 
                         ; THE CAR TO DRIVE ONE WAY WHEN WE WANT THE OTHER IF WE WERE GOING FORWARD
 RETURN

; ********************** CALCULATE MEASUREMENT PRECISION BASED ON SPEED **********************
CALCPRECISION:
 MOVF   CCPR1L, W        ; GET THE SPEED VALUE INTO WREG SUBTRACT 32 FROM THE SPEED TO OFFSET IT TO
 ADDLW  B'11100000'      ; THE RANGE OF 0x37 - 0x3B. THESE VALUES CORRESPOND TO A CONSTANT ARRAY THAT
                         ; HOLDS VALUES THAT ADJUST THE LEVEL OF PRECISION WE USE FOR STEERING CALCULATIONS
                         ; BASED ON HOW FAST WE ARE GOING (THE SLOWER WE ARE GOING, THE MORE PRECISION USED)
 MOVWF  FSR1L, W         ; LOAD THE CALCULATED ADDRESS INTO FSR1 SO WE CAN RETRIEVE THE CORRECT AMOUNT OF PRECISION
 RETURN


; ****************************************** TURN ********************************************
TURN:
 CPFSGT ANWREG        ; IF AN1 > AN0, THEN WE SHOULD TURN RIGHT IF WE ARE GOING FORWARD. BUT BECAUSE WE WANT
 BTG    CCR, TURNLEFT ; TO FLIP OUR DIRECTION IF WE ARE GOING WHILE IN REVERSE, WE WILL TOGGLE THE BIT RATHER THAN
                      ; SET IT SO THAT THE DRIVE LOGIC WILL INVERT WHICH WAY WE ARE TRUNING IF WE ARE IN REVERSE.
 BTFSC  CCR, TURNLEFT ; IF AFTER POSSIBLY TOGGLING THE TURNING BIT, CHECK IF IT IS SET TO DECIDE WHICH DIRECTION TO TURN IN
 BRA    STEERLEFT     ; IF IT IS SET, WE ARE TURNING LEFT

; NO COMPARISON OR BRANCH NEEDED FOR TURNING RIGHT AS IT IS IMPLIED BY THE PREVIOUS TWO AND SAVES TIME
; *************************************** TURN RIGHT *****************************************
 NEGF   WREG          ; NEGATE SMALLER VALUE (AN0)
 ADDWF  ANWREG, W     ; (AN1 - AN0)
 RLCF   WREG          ; SHIFT <6:3> -> <7:4>
 SWAPF  WREG          ; SWAP <7:4> -> <3:0>
 ANDLW  0x0F          ; KEEP xxxx1111 BITS
 MOVWF  ANWREG        ; STORE THE TRUNING VALUE IN ANWREG FOR THE DRIVEREVERSE LOGIC FLIPPING THE TURNING DIRECTION
 ADDWF  RTURNMIN, W   ; ADD MINIMUM RIGHT TURN VALUE (RTRUNMIN + TURN VALUE)
 MOVWF  CCPR2L        ; LOAD THE CALCULATED STEER VALUE
 BCF    CCR, TURNLEFT ; CLEAR THE TURN FLAG AT THE END OF THE STEER LOGIC SO THAT IF WE ARE IN REVERSE 
                      ; (DRIVING IS CALCULATED JUST BEFORE STEERING) WE CAN FLIP OUR TURNING BY TELLING 
                      ; THE CAR TO DRIVE ONE WAY WHEN WE WANT THE OTHER IF WE WERE GOING FORWARD
 BSF ANWREG, TURNINGRIGHT ; SET THE TURNING RIGHT FLAG SO THE DRIVEREVERSE LOGIC KNOWS WHAT DIRECTION TO CHANGE TO

 MOVF   CCPR1L, W   ; GET THE CURRENT SPEED
 NEGF   WREG        ; NEGATE THE SPEED VALUE
 ADDWF  FWDMAX, W   ; (FWDMAX - SPEED)
 ADDWF  CCPR2L      ; (TURN + SPEED) -> TURN MORE THE SLOWER WE ARE GOING
 RETURN

; *************************************** TURN LEFT ******************************************
STEERLEFT:
 NEGF   ANWREG      ; NEGATE SMALLER VALUE (AN1)
 ADDWF  ANWREG, W   ; (AN0 - AN1)
 RLCF   WREG        ; SHIFT <6:3> -> <7:4>
 SWAPF  WREG        ; SWAP <7:4> -> <3:0>
 ANDLW  0x0F        ; KEEP xxxx1111 BITS
 MOVWF  ANWREG      ; STORE THE TRUNING VALUE IN ANWREG FOR THE DRIVEREVERSE LOGIC FLIPPING THE TURNING DIRECTION
 NEGF   WREG          ; GET NEGATEIVE VALUE OF 4-MSBs
 ADDWF  LTURNMIN, W   ; ADD MINIMUM LEFT TURN VALUE (LTRUNMIN - TURN VALUE)
 MOVWF  CCPR2L        ; LOAD THE CALCULATED STEER VALUE
 BCF    CCR, TURNLEFT ; CLEAR THE TURN FLAG AT THE END OF THE STEER LOGIC SO THAT IF WE ARE IN REVERSE 
                      ; (DRIVING IS CALCULATED JUST BEFORE STEERING) WE CAN FLIP OUR TURNING BY TELLING 
                      ; THE CAR TO DRIVE ONE WAY WHEN WE WANT THE OTHER IF WE WERE GOING FORWARD
 BSF ANWREG, TURNINGLEFT ; SET THE TURNING RIGHT FLAG SO THE DRIVEREVERSE LOGIC KNOWS WHAT DIRECTION TO CHANGE TO

 MOVF   CCPR1L, W   ; GET THE CURRENT SPEED
 NEGF   WREG        ; NEGATE THE SPEED VALUE
 ADDWF  FWDMAX, W   ; (FWDMAX - SPEED)
 NEGF   WREG        ; NEGATE THE SPEED DIFFERENCE
 ADDWF  CCPR2L      ; (TURN - SPEED) -> TURN MORE THE SLOWER WE ARE GOING
 RETURN



; ////////////////////////////////////////////////////////////////////////////////////////////
; ///////////////////////////////// INITIALIZATION ROUTINES //////////////////////////////////
; ////////////////////////////////////////////////////////////////////////////////////////////

; ************************ INITIALIZE THE VALUE LIMITS OF THE CONTROLS ***********************
INITREGISTERLIMS:
 MOVLF D'91',  FWDMAX     ; SET VALUE FOR MAX FORWARD SPEED
 MOVLF D'86',  FWDMIN     ; SET VALUE FOR MIN FORWARD SPEED
 MOVLF D'74',  REVMAX     ; SET VALUE FOR MAX REVERSE SPEED
 MOVLF D'76',  REVMIN     ; SET VALUE FOR MIN REVERSE SPEED
 MOVLF D'42',  REVVAL     ; SET VALUE FOR SWITCHING TO REVERSE
 MOVLF D'75',  LTURNMAX   ; SET VALUE FOR MAX LEFT TURN
 MOVLF D'91',  LTURNMIN   ; SET VALUE FOR MIN LEFT TURN
 MOVLF D'100', NTURNVAL   ; SET VALUE FOR DRIVING STRAIGHT
 MOVLF D'125', RTURNMAX   ; SET VALUE FOR MAX RIGHT TURN
 MOVLF D'109', RTURNMIN   ; SET VALUE FOR MIN RIGHT TURN
 RETURN


; ********************* INITIALIZE THE VALUE SPEED BASED PRECISION VALUES ********************
INITPRECISION:
 MOVLF B'11111111', PRECISION0
 MOVLF B'11111111', PRECISION1
 MOVLF B'11111110', PRECISION2
 MOVLF B'11111100', PRECISION3
 MOVLF B'11111000', PRECISION4
 RETURN

; ************************************* INITIALIZE I/O  **************************************
INITIO:
 SETF TRISA ; SET REGISTERS ASSOCIATED WITH THE XXXXA PINS TO BE INPUTS
 CLRF TRISC ; SET REGISTERS ASSOCIATED WITH THE XXXXC PINS TO BE OUTPUTS
 CLRF LATC  ; MAKE SURE WE START WITHOUT GARBAGE DATA
 RETURN

; ************************************* INITIALIZE PWM  **************************************
INITPWM: ; INITIALIZES CCP2, CCP2CON, Timer2
 MOVLF PR2VAL,      PR2       ; Set default PWM_frequency (60Hz)
 MOVFF NTURNVAL,    CCPR2L    ; SET THE INITIAL VALUE OF CCPR2L (STEERING CONTROL) TO THE NEUTRAL TURN VALUE
 MOVLF CCPCON,      CCP2CON   ; SET 2-LSBs OF NEUTRAL TURN VALUE AND SET CCP2 TO PWM MODE
 MOVFF FWDMIN,      CCPR1L    ; SET THE INITIAL VALUE OF CCPR1L (SPEED CONTROL) TO THE NEUTRAL SPEED VALUE
 MOVLF CCPCON,      CCP1CON   ; SET 2-LSBs OF NEUTRAL TURN VALUE AND SET CCP1 TO PWM MODE
 MOVLF B'00000110', T2CON     ; <7> Unimp., <6:3> T2 POSTSCALER, <2> T2 ON BIT, <1:0> T2 PRESCALER (1x -> 16x)
 RETURN

; *********************************** ENABLE A/D INTERRUPTS **********************************
INITADINTERRUPTS:
 BCF PIR1,ADIF   ; CLEAR THE PERIPHERAL (A/D) INTERRUPT FLAG
 BSF PIE1,ADIE   ; SET PERIPHERAL (A/D) INTERRUPTS TO ON
 BSF INTCON,GIE  ; SET GLOBAL INTERRUPTS TO ON
 BSF INTCON,PEIE ; SET PERIPHERAL (A/D) INTERRUPTS TO ON
 RETURN

; ******************************** INITIALIZE A/D CONVERSION *********************************
INITADC:
 MOVLF B'00000000', ADCON1 ; <7>LEFT JUSTIFY RESULT, <6>CLOCK CONVERSION SELECTION-SET #1, <5:4> U, <3:0> SET PINS AN7:AN0 TO ANALOG-IN
 MOVLF B'11000001', ADCON0 ; <7:6>SET CONVERSION CLOCK TO INTERNAL A/D RC OSCILLATOR, <5:3> CHANNEL 0 (AN0) IS THE INPUT, <2> GO/DONE IS NOT SET YET BECAUSE WE DON'T WANT IT TO RUN YET, <1> U, <0> TURN ON THE CONVERTER
 CALL WAIT20US             ; WAIT THE REQUIRED ACQUISITION TIME
 BSF ADCON0, GO            ; AFTER WAITING THE REQUIRED AMOUNT, START THE CONVERSION
 RETURN




; ////////////////////////////////////////////////////////////////////////////////////////////
; //////////////////////////////////// INERRUPT ROUTINES /////////////////////////////////////
; ////////////////////////////////////////////////////////////////////////////////////////////

; ************************************ HANDLE INTERRUPTS *************************************
INTERRUPTHANDLER:
 MOVWF W_TEMP      ; STORE THE VALUE IN WREG TO RETURN WITH THE PROPERVALUES
 BTFSC PIR1,ADIF   ; CHECK IF THE A/D CONVERTER INTERRUPT FLAG IS WHAT BROUGHT US HERE
 CALL  ADINTERRUPT ; IF IT WAS, HANDLE IT
 MOVF  W_TEMP, W   ; RESTORE THE VALUE THAT WAS IN WREG
 RETFIE

; ********************************* HANDLE AN A/D INTERRUPT **********************************
ADINTERRUPT:
; MOVFF ADRESH, INDF0     ; MOVE THE RESULT OF THE A/D CONVERSION INTO THE CURRENT ANxREG
 CALL  UPDATEFSR         ; HANDLE UPDATING THE FSR'S CURRENT REGISTER AND CONTROL FLAGS
 CALL  RESETADCONVERSION ; RESET THE CONVERSION PROCESS
 RETURN

; ********************************* UPDATE FSR AND SET FLAGS *********************************
UPDATEFSR:
 CALL  CHECKSTEER
 CALL  CHECKDRIVE
 INCF  FSR0L
 BTFSC FSR0L, 2          ; CHECK THE "PIVOT" BIT (THE BIT THAT SIGNIFIES THE END OF THE ARRAY) FOR IT IS SET
 BCF   FSR0L, 2          ; IF THE PIVOT BIT IS SET, LOAD THE BASE ([0]) REGISTER
 RETURN

CHECKSTEER:
 BTFSC FSR0L, 0          ; IF THE 0 BIT HAS BEEN SET, WE HAVE READ THE VALUES OFF OF AN0 AND
 BSF   CCR,   CALCSTEER  ; AN1 SO WE CAN CALC A NEW DIRECTION
 BTFSC FSR0L, 1
 BCF   CCR,   CALCSTEER
 RETURN

CHECKDRIVE:
 BTFSC FSR0L, 1          ; IF THE 1 BIT HAS BEEN SET, WE HAVE READ FROM THE FRONT SHORT RANGE
 BSF   CCR,   CALCDRIVE  ; SENSOR SO WE CAN CALC A NEW SPEED
 BTFSC FSR0L, 0
 BCF   CCR,   CALCDRIVE
 RETURN

; ********************************** RESET A/D CONVERSION ************************************
RESETADCONVERSION:
 BCF   PIR1,ADIF ; RESET THE A/D CONVERTION INTERRUPT FLAG
 CALL  INCADCON
 CALL  WAIT20US  ; WAIT THE REQUIRED ACQUISITION TIME
 BSF   ADCON0,GO ; START THE CONVERSION PROCESS
 RETURN 

; ***************************** INCREMENT THE A/D PIN BEING READ *****************************
INCADCON:
 MOVLW D'8'         ; INCREMENT THE ANx PIN WE ARE READING FROM
 ADDWF ADCON0, F    ; ADCON0: 11txx001; xx ARE THE PINS USED FOR AN0-AN3
 BTFSC ADCON0, CHS2 ; AND t IS THE PIN USED FOR AN4+ WHICH WE DON'T NEED, SO IT IF IS SET
 BCF   ADCON0, CHS2 ; CLEAR IT BECAUSE IT RESETS BACK TO AN0: i.e. BCF <5> 11100001(AN4) -> 11000001(AN0)
 RETURN



; ////////////////////////////////////////////////////////////////////////////////////////////
; ////////////////////////////////////// WAIT ROUTINES ///////////////////////////////////////
; ////////////////////////////////////////////////////////////////////////////////////////////

; ************************** WAIT ~20 MICRO SECONDS FOR ACQUISITION **************************
WAIT20US:
 MOVLF D'20', WAITCOUNTER
WAITLOOP:
 DECFSZ WAITCOUNTER
 BRA WAITLOOP
  RETURN

 END
